#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_mesh_shader : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_ballot : enable

#include <gct/aabb_type.h>
#include <gct/scene_graph/matrix_pool.h>
#include <gct/global_uniforms.h>

layout(local_size_x = 32, local_size_y = 1 ) in;

struct task_data {
  uint meshlet_index[ 32 ];
  mat4 w2s;
  uint tasklet_id;
};
taskPayloadSharedEXT task_data td;


ivec3 index_to_task_offset( uint v ) {
  const int x_index = int( v & 0x7 ) - 4;
  const int y_index = int( ( v >> 3 ) & 0xF ) - 8;
  const int layer = int( v >> 7 );
  const bool hole =
    layer >= 1 &&
    x_index >= -2 &&
    x_index < 2 &&
    y_index >= -4 &&
    y_index < 4;
  return
    hole ?
    ivec3( 0, 0, -1 ) :
    ivec3( x_index, y_index, layer );
}

ivec2 index_to_meshlet_offset( uint v, ivec3 task_offset ) {
  const int x_index = int( v & 0x7u );
  const int y_index = int( v >> 3 );
  return ivec2( x_index + task_offset.x * 8, y_index + task_offset.y * 4 );
}

void main() {
  const float grid_width = 0.5;
  const vec4 world_center = global_uniforms.eye_pos;
  const ivec2 center_primitive = ivec2( floor( world_center.xz / grid_width ) );
  const vec2 aligned_world_center = vec2( center_primitive ) * grid_width;

  const ivec3 task_offset = index_to_task_offset( gl_WorkGroupID.x );
  const ivec2 meshlet_offset = index_to_meshlet_offset( gl_LocalInvocationID.x, task_offset );
  const float edge_length = grid_width * ( 1 << task_offset.z );
  const vec2 primitive_pos = aligned_world_center + vec2( meshlet_offset.xy * 4 ) * edge_length;
  aabb_type meshlet_aabb;
  meshlet_aabb.min = vec4( primitive_pos.x, 0, primitive_pos.y, 1 );
  meshlet_aabb.max = vec4( primitive_pos.x + edge_length * 4, 255, primitive_pos.y + edge_length * 4, 1 );
  const bool eye_pos_is_inside = inside( meshlet_aabb, global_uniforms.eye_pos );

  const mat4 w2s =
    matrix_pool[ global_uniforms.projection_matrix ] *
    matrix_pool[ global_uniforms.camera_matrix ];

  const aabb_type screen_space_meshlet_aabb =
    transform_aabb( w2s, meshlet_aabb );

  const bool in_frustum =
    screen_space_meshlet_aabb.min.x <= 1.0 &&
    screen_space_meshlet_aabb.min.y <= 1.0 &&
    screen_space_meshlet_aabb.min.z <= 1.0 &&
    screen_space_meshlet_aabb.max.x >= -1.0 &&
    screen_space_meshlet_aabb.max.y >= -1.0 &&
    screen_space_meshlet_aabb.max.z >= -1.0;
  
  const bool visible = task_offset.z >= 0 && ( eye_pos_is_inside || in_frustum );
  
  const uvec4 visible_bits = subgroupBallot( visible );
  const uint offset = subgroupBallotExclusiveBitCount( visible_bits );
  const uint total = subgroupBallotBitCount( visible_bits );

  td.w2s = w2s;

  td.tasklet_id = gl_WorkGroupID.x;
  if( visible ) {
    td.meshlet_index[ offset ] = gl_LocalInvocationID.x;
  }

  EmitMeshTasksEXT( total, 1, 1 );
}

