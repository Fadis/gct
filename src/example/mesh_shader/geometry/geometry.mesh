#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_mesh_shader : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_8bit_storage : enable

#define GCT_ENABLE_8BIT_16BIT_STORAGE
#include <gct/scene_graph.h>
#include <gct/global_uniforms.h>
#include <gct/scene_graph/accessor.h>
#include <gct/global_uniforms.h>

layout(local_size_x = 32, local_size_y = 1 ) in;

layout(triangles, max_vertices = 96, max_primitives = 32) out;

layout (location = 0) out vec4 output_position[];
layout (location = 1) out vec3 output_normal[];
layout (location = 2) out vec3 output_tangent[];
layout (location = 3) out vec2 output_tex_coord[];
layout (location = 4) out vec4 output_optflow[];
layout (location = 5) flat out vec4 output_id[];
layout (location = 6) out vec4 output_previous_position[];

struct task_data {
  uint resource_pair_id;
};
taskPayloadSharedEXT task_data td;

void main() {
  const resource_pair_type id = resource_pair[ push_constants.instance + td.resource_pair_id ];
  const primitive_resource_index_type prim = primitive_resource_index[ id.prim ];
  const mesh_type mesh = mesh_pool[ prim.mesh ];
  const uint meshlet_id = gl_WorkGroupID.x;
  const uint vertex_count = min( mesh.vertex_count - meshlet_id * 96, 96 );
  SetMeshOutputsEXT( vertex_count, vertex_count / 3 );

  const uint local_primitive_id = gl_LocalInvocationID.x;
  const uint local_vertex_id = local_primitive_id * 3u;

  if( vertex_count <= local_vertex_id ) return; 
  
  const instance_resource_index_type inst = instance_resource_index[ id.inst ];
  
  const mat4 l2w = matrix_pool[ inst.world_matrix ];

  const mat4 w2s =
    matrix_pool[ global_uniforms.projection_matrix ] *
    matrix_pool[ global_uniforms.camera_matrix ];
  const mat4 l2s =
    w2s *
    l2w;

  const vertex_attribute v0 = read_vertex_attribute( mesh, gl_GlobalInvocationID.x * 3u + 0u );
  const vertex_attribute v1 = read_vertex_attribute( mesh, gl_GlobalInvocationID.x * 3u + 1u );
  const vertex_attribute v2 = read_vertex_attribute( mesh, gl_GlobalInvocationID.x * 3u + 2u );

  gl_MeshVerticesEXT[ local_vertex_id ].gl_Position = l2s * v0.position;
  gl_MeshVerticesEXT[ local_vertex_id + 1u ].gl_Position = l2s * v1.position;
  gl_MeshVerticesEXT[ local_vertex_id + 2u ].gl_Position = l2s * v2.position;
  output_position[ local_vertex_id ] = l2w * v0.position;
  output_position[ local_vertex_id + 1u ] = l2w * v1.position;
  output_position[ local_vertex_id + 2u ] = l2w * v2.position;
  output_normal[ local_vertex_id ] = ( l2w * v0.normal ).xyz;
  output_normal[ local_vertex_id + 1u ] = ( l2w * v1.normal ).xyz;
  output_normal[ local_vertex_id + 2u ] = ( l2w * v2.normal ).xyz;
  output_tangent[ local_vertex_id ] = ( l2w * v0.tangent ).xyz;
  output_tangent[ local_vertex_id + 1u ] = ( l2w * v1.tangent ).xyz;
  output_tangent[ local_vertex_id + 2u ] = ( l2w * v2.tangent ).xyz;
  output_tex_coord[ local_vertex_id ] = v0.tex_coord0.xy;
  output_tex_coord[ local_vertex_id + 1u ] = v1.tex_coord0.xy;
  output_tex_coord[ local_vertex_id + 2u ] = v2.tex_coord0.xy;
  output_optflow[ local_vertex_id ] = vec4( 0, 0, 0, 0 );
  output_optflow[ local_vertex_id + 1u ] = vec4( 0, 0, 0, 0 );
  output_optflow[ local_vertex_id + 2u ] = vec4( 0, 0, 0, 0 );
  output_id[ local_vertex_id ] = vec4( id.inst, id.prim, 0, 0 );
  output_id[ local_vertex_id + 1u ] = vec4( id.inst, id.prim, 0, 0 );
  output_id[ local_vertex_id + 2u ] = vec4( id.inst, id.prim, 0, 0 );
  gl_PrimitiveTriangleIndicesEXT[ local_primitive_id ] = uvec3( local_vertex_id, local_vertex_id + 1, local_vertex_id + 2 );
}

