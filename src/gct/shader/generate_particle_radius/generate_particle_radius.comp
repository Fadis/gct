#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_image_load_formatted : enable

// 8bit、16bitの値のバッファを読めるようにする拡張を使う
// 頂点バッファをシェーダーから読むのに使う
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_8bit_storage : enable

// Subgroup演算拡張を使う
#extension GL_KHR_shader_subgroup_arithmetic : enable

#define GCT_ENABLE_8BIT_16BIT_STORAGE
#define GCT_USE_IMAGE_POOL_WITHOUT_FORMAT
#include <gct/constants.h>
#include <gct/scene_graph.h>
#include <gct/scene_graph/accessor.h>
#include <gct/topology_id.h>
#include <gct/distance_constraint.h>
#include <gct/vertex_to_primitive.h>
#include <gct/accessor.h>
layout(local_size_x = 128, local_size_y = 1 ) in;

void main() {
  // 描画対象のID
  const resource_pair_type id = resource_pair[ push_constants.instance ];
  // メッシュが属すノードの情報を得る
  const instance_resource_index_type inst = instance_resource_index[ id.inst ];
  // メッシュの情報を取得する
  const primitive_resource_index_type prim = primitive_resource_index[ id.prim ];
  const mesh_type mesh = mesh_pool[ prim.mesh ];

  // ローカル座標系からワールド座標系への変換行列 
  const mat4 l2w = matrix_pool[ inst.world_matrix ];

  // スレッドが担当するプリミティブが存在するかを調べる
  // 端数の頂点を扱う最後のメッシュレットではスレッド数より少ない数のプリミティブしかない可能性がある
  const uint vertex_id = gl_GlobalInvocationID.x;
  const bool in_range = mesh.unique_vertex_count > vertex_id;

  if( !in_range ) return;

  if( mesh.particle_offset == 0xFFFFFFFF ) return;
  
  if( mesh.vertex_to_primitive_offset == 0xFFFFFFFF ) return;

  const uint accessor_id = mesh.accessor;
  const vec4 wp0 = l2w * read_vertex( accessor_pool[ accessor_id + 1 ], vertex_id, vec4( 0.0, 0.0, 0.0, 1.0 ) );

  float max_distance = 0.001;

  uint iter = vertex_to_primitive_begin( vertex_id, mesh.vertex_to_primitive_offset );
  for( uint i = 0u; i != 32u; ++i ) {
    if( !vertex_to_primitive_is_end( iter ) ) {
      const uint pid = vertex_to_primitive_get( iter );

      vec4 wp1 = l2w * read_vertex_position( mesh, pid * 3u + 0u );
      vec4 wp2 = l2w * read_vertex_position( mesh, pid * 3u + 1u );
      vec4 wp3 = l2w * read_vertex_position( mesh, pid * 3u + 2u );
      max_distance = max(
        max_distance,
        max(
          distance( wp0.xyz, wp1.xyz ),
          distance( wp0.xyz, wp2.xyz ),
          distance( wp0.xyz, wp3.xyz )
        )
      );

      iter = vertex_to_primitive_next( iter );
    }
  }

  particle_pool[ mesh.particle_offset + vertex_id ].radius = max_distance; 
}

