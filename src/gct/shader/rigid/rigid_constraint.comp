#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_image_load_formatted : enable

// 8bit、16bitの値のバッファを読めるようにする拡張を使う
// 頂点バッファをシェーダーから読むのに使う
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_8bit_storage : enable

// Subgroup演算拡張を使う
#extension GL_KHR_shader_subgroup_arithmetic : enable

#define GCT_ENABLE_8BIT_16BIT_STORAGE
#define GCT_USE_IMAGE_POOL_WITHOUT_FORMAT
#include <gct/constants.h>
#include <gct/scene_graph.h>
#include <gct/scene_graph/accessor.h>
#include <gct/xpbd/rigid_constraint.h>
#include <gct/aabb_type.h>
// per constraint, per rigid
layout(local_size_x = 32, local_size_y = 1 ) in;

void main() {
  // 描画対象のID
  const resource_pair_type id = resource_pair[ push_constants.instance + gl_GlobalInvocationID.y ];
  // メッシュが属すノードの情報を得る
  const instance_resource_index_type inst = instance_resource_index[ id.inst ];
  // メッシュの情報を取得する
  const primitive_resource_index_type prim = primitive_resource_index[ id.prim ];
  const mesh_type mesh = mesh_pool[ prim.mesh ];

  const uint constraint_index = gl_SubgroupInvocationID;
  
  const float dt = 1.0/60.0;
  const uint substep_count = 20;
  const float h = dt/substep_count;

  if( inst.rigid == 0xFFFFFFFF ) return;

  const rigid_type rigid = rigid_pool[ inst.rigid ];
  
  vec4 dx = vec4( 0.0, 0.0, 0.0, 0.0 );
  rigid_collision_dx_dq sum = rigid_collision_dx_dq( vec3( 0, 0, 0 ), vec4( 0, 0, 0, 0 ), 0u, 0u );
  for( uint constraint_block_id = 0u; constraint_block_id != 16u; constraint_block_id++ ) {
    rigid_collision_dx_dq dx_dq = rigid_collision_constraint_dx(
      rigid.collision_constraint_offset,
      constraint_block_id * gl_SubgroupSize + constraint_index,
      h
    );
    dx_dq.dx_count = subgroupAdd( dx_dq.dx_count );
    dx_dq.dq_count = subgroupAdd( dx_dq.dq_count );
    dx_dq.dx = subgroupAdd( dx_dq.dx );
    dx_dq.dq = subgroupAdd( dx_dq.dq );
    sum.dx += dx_dq.dx;
    sum.dq += dx_dq.dq;
    sum.dx_count += dx_dq.dx_count;
    sum.dq_count += dx_dq.dq_count;
  }
  {
    const uint block_count = mesh.unique_vertex_count / gl_SubgroupSize + ( ( mesh.unique_vertex_count % gl_SubgroupSize > 0 ) ? 1u : 0u );
    for( uint block_id = 0u; block_id < block_count; ++block_id ) {
      const uint vertex_id = block_id * gl_SubgroupSize + gl_SubgroupInvocationID;
      rigid_collision_dx_dq dx_dq =
        ( vertex_id < mesh.unique_vertex_count ) ?
        rigid_border_dx(
          inst.rigid,
          mesh.particle_offset + vertex_id,
          aabb_type(
            vec4( -2.6, -100.0, -2.1, 1.0 ),
            vec4( 2.6, -0.05, 1.5, 1.0 )
          ),
          h
        ) :
        rigid_collision_dx_dq( vec3( 0, 0, 0 ), vec4( 0, 0, 0, 0 ), 0u, 0u );
      dx_dq.dx_count = subgroupAdd( dx_dq.dx_count );
      dx_dq.dq_count = subgroupAdd( dx_dq.dq_count );
      dx_dq.dx = subgroupAdd( dx_dq.dx );
      dx_dq.dq = subgroupAdd( dx_dq.dq );
      sum.dx += dx_dq.dx;
      sum.dq += dx_dq.dq;
      sum.dx_count += dx_dq.dx_count;
      sum.dq_count += dx_dq.dq_count;
    }
  }
  if( sum.dx_count != 0u ) {
    sum.dx /= sum.dx_count;
  }
  if( sum.dq_count != 0u ) {
    sum.dq /= sum.dq_count;
  }
  if( constraint_index == 0u ) {
    matrix_pool[ rigid_pool[ inst.rigid ].trs ][ 0 ].xyz += sum.dx;
    const vec4 q = matrix_pool[ rigid_pool[ inst.rigid ].trs ][ 1 ];
    matrix_pool[ rigid_pool[ inst.rigid ].trs ][ 1 ] = quaternion_normalize( q + sum.dq );
    rigid_pool[ inst.rigid ].constraint_count = sum.dx_count;
  }
}

