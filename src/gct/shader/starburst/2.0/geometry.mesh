#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_image_load_formatted : enable

// メッシュシェーダー拡張を使う
#extension GL_EXT_mesh_shader : enable

// 8bit、16bitの値のバッファを読めるようにする拡張を使う
// 頂点バッファをシェーダーから読むのに使う
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_8bit_storage : enable

#define GCT_USE_IMAGE_POOL_WITHOUT_FORMAT
#define GCT_SHADER_SCENE_GRAPH_DISABLE_PUSH_CONSTANT
#define GCT_ENABLE_8BIT_16BIT_STORAGE
#include <gct/scene_graph.h>
#include <gct/global_uniforms.h>
#include <gct/scene_graph/accessor.h>
#include <gct/scene_graph/omnishadow.h>

layout (std430, binding = 13) buffer AFState {
  uint history;
  uint max_history;
  float depth;
  float znear;
  float zfar;
  float focal_distance;
  float lens_size;
  float sensor_size;
  float apeture_rotation;
  float visible_range;
} af_state;

layout(push_constant) uniform PushConstants {
  vec2 sensor_size;
  uint light;
  uint texture_id;
  uint output_color;
} push_constants;

layout(local_size_x = 1, local_size_y = 1 ) in;

layout(triangles, max_vertices = 4, max_primitives = 2) out;

layout (location = 0) out vec2 output_texcoord[];

void main() {
  const vec3 light_pos = light_pool[ push_constants.light ].world_position.xyz;
  const vec3 eye_pos = global_uniforms.eye_pos.xyz;

  const float shadow_level = simple_shadow_omni(
    light_pool[ push_constants.light ].shadow_map,
    eye_pos,
    light_pos
  );

  const vec4 light_pos_in_camera =
    matrix_pool[ global_uniforms.camera_matrix ] * vec4( light_pos, 1.0 );

  vec4 light_pos_in_screen =  
    matrix_pool[ global_uniforms.projection_matrix ] * light_pos_in_camera;
  light_pos_in_screen /= light_pos_in_screen.w;
  const ivec2 image_size = imageSize( image_pool_2d[ push_constants.output_color ] ).xy;
  const ivec2 screen_pos = ivec2( image_size * ( light_pos_in_screen.xy * vec2( 0.5,  0.5 ) + 0.5 ) );
  
  const bool visible = !(
    light_pos_in_screen.x < -1.0 || light_pos_in_screen.x > 1.0 ||
    light_pos_in_screen.y < -1.0 || light_pos_in_screen.y > 1.0 ||
    light_pos_in_camera.z > 0.0 || shadow_level == 0.0
  );

  SetMeshOutputsEXT(
    visible ? 4u : 0u,
    visible ? 2u : 0u
  );

  if( !visible ) return;

  const float radius = af_state.lens_size;
  const vec2 center_pos = light_pos_in_screen.xy;
  const vec2 v0 = center_pos + vec2( -radius,  radius )/push_constants.sensor_size;
  const vec2 v1 = center_pos + vec2( -radius, -radius )/push_constants.sensor_size;
  const vec2 v2 = center_pos + vec2(  radius,  radius )/push_constants.sensor_size;
  const vec2 v3 = center_pos + vec2(  radius, -radius )/push_constants.sensor_size;

  gl_MeshVerticesEXT[ 0 ].gl_Position = vec4( v0, 0, 1 );
  output_texcoord[ 0 ] = vec2( 0, 1 );
  gl_MeshVerticesEXT[ 1 ].gl_Position = vec4( v1, 0, 1 );
  output_texcoord[ 1 ] = vec2( 0, 0 );
  gl_MeshVerticesEXT[ 2 ].gl_Position = vec4( v2, 0, 1 );
  output_texcoord[ 2 ] = vec2( 1, 1 );
  gl_MeshVerticesEXT[ 3 ].gl_Position = vec4( v3, 0, 1 );
  output_texcoord[ 3 ] = vec2( 1, 0 );

  gl_PrimitiveTriangleIndicesEXT[ 0 ] = uvec3( 0, 1, 2 );
  gl_PrimitiveTriangleIndicesEXT[ 1 ] = uvec3( 2, 1, 3 );
}

