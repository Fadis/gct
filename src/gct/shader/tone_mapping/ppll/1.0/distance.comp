#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_image_load_formatted : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

#define GCT_USE_IMAGE_POOL_WITHOUT_FORMAT
#include <gct/constants.h>
#include <gct/global_uniforms.h>
#include <gct/lighting.h>
#include <gct/scene_graph/image_pool.h>
#include <gct/scene_graph/texture_pool.h>
#include <gct/scene_graph/light_pool.h>
#include <gct/scene_graph/matrix_pool.h>
#include <gct/scene_graph/ppll.h>
#include <gct/depth.h>

layout (std430, binding = 13) buffer AFState {
  uint history;
  uint max_history;
  float depth;
  float znear;
  float zfar;
  float focal_distance;
  float lens_size;
  float sensor_size;
  float apeture_rotation;
  float visible_range;
} af_state;

layout(push_constant) uniform PushConstants {
  ivec2 focus_pos;
  uint ppll_state_id;
  uint gbuffer;
  uint position;
  uint start;
  uint next;
} push_constants;

layout(local_size_x = 16, local_size_y = 16 ) in;

shared float[ 8 ] temp;

void main()  {
  ivec2 screen_pos = ( push_constants.focus_pos - 8 ) + ivec2( gl_GlobalInvocationID.xy );

  ppll_iter iter = ppll_begin(
    push_constants.ppll_state_id,
    ppll_image( push_constants.gbuffer, push_constants.position, push_constants.start, push_constants.next ),
    screen_pos
  );
  ppll_iter nearest = ppll_nearest( iter );
  const bool has_layer = !ppll_is_end( nearest );
  const float encoded_depth = ppll_get_depth( nearest );

  const float linear_depth = ( encoded_depth == 0.0 ) ? ( ( af_state.znear + af_state.zfar ) / 2.0 ) : decode_depth( encoded_depth, af_state.znear, af_state.zfar );
  const float subgroup_sum = subgroupAdd( linear_depth );
  temp[ gl_SubgroupID ] = subgroup_sum;
  barrier();

  const float sum = subgroupAdd( ( gl_SubgroupInvocationID < 8 ) ? temp[ gl_SubgroupInvocationID ] : 0.0 );
  const float average_depth = sum * ( 1.0 / ( 16.0 * 16.0 ) );

  const uint history = min( af_state.history + 1, af_state.max_history );
  const float new_depth = ( average_depth + af_state.depth * ( history - 1 ) )/history;

  if( gl_GlobalInvocationID == ivec3( 0, 0, 0 ) ) {
    af_state.depth = new_depth;
    af_state.history = history;
  }
}

