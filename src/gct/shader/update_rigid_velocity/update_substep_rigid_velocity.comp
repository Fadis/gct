#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_image_load_formatted : enable

// 8bit、16bitの値のバッファを読めるようにする拡張を使う
// 頂点バッファをシェーダーから読むのに使う
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_8bit_storage : enable

// Subgroup演算拡張を使う
#extension GL_KHR_shader_subgroup_arithmetic : enable

#define GCT_ENABLE_8BIT_16BIT_STORAGE
#define GCT_USE_IMAGE_POOL_WITHOUT_FORMAT
#include <gct/constants.h>
#include <gct/scene_graph.h>
#include <gct/quaternion.h>
layout(local_size_x = 1, local_size_y = 1 ) in;

void main() {
  // 描画対象のID
  const resource_pair_type id = resource_pair[ push_constants.instance + gl_GlobalInvocationID.x ];
  // メッシュが属すノードの情報を得る
  const instance_resource_index_type inst = instance_resource_index[ id.inst ];

  if( inst.rigid == 0xFFFFFFFF ) return;
 
  const float delta_t = 1.0/60.0;
  const uint num_substeps = 10;
  const float h = delta_t / num_substeps;
  const float g = 9.80665;

  vec3 x = matrix_pool[ rigid_pool[ inst.rigid ].trs ][ 0 ].xyz;
  vec3 x_prev = matrix_pool[ rigid_pool[ inst.rigid ].trs_previous ][ 0 ].xyz;
  vec4 q = matrix_pool[ rigid_pool[ inst.rigid ].trs ][ 1 ];
  vec4 q_prev = matrix_pool[ rigid_pool[ inst.rigid ].trs_previous ][ 1 ];
  vec3 v_prev = rigid_pool[ inst.rigid ].linear_velocity.xyz;
  vec3 v = ( x - x_prev )/h;
  v = ( dot( v_prev, v ) >= -0.0 ) ? v : vec3( 0, 0, 0 );

  rigid_pool[ inst.rigid ].linear_velocity.xyz = v;
  vec4 delta_q = quaternion_quaternion_mult( q, quaternion_inverse( q_prev ) );
  vec3 omega_prev = rigid_pool[ inst.rigid ].angular_velocity.xyz;
  vec3 omega = 2.0 * delta_q.xyz / h;
  omega = ( delta_q.w >= 0 ) ? omega : -omega;
  //omega = ( dot( v_prev, v ) >= 0.0 ) ? omega : vec3( 0, 0, 0 );
  //float ol = length( omega );
  //omega = ( ol > 50.0 ) ? omega/ol : omega;
  omega = max( vec3( -4, -4, -4 ), min( vec3( 4, 4, 4 ), omega ) );
  //omega *= max( 0.0, min( 1.0, 1.0 - (1.0/( 65536.0*256.0 ) )*rigid_pool[ inst.rigid ].constraint_count ) );
  //omega *= pow( 0.999, min( rigid_pool[ inst.rigid ].constraint_count, 200.0 ) );
  omega *= ( rigid_pool[ inst.rigid ].constraint_count > 0 ) ? 0.98 : 1.0;
  //omega *= 0.99;
  rigid_pool[ inst.rigid ].angular_velocity.xyz = omega;
}

