#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_nonuniform_qualifier : enable

// メッシュシェーダー拡張を使う
#extension GL_EXT_mesh_shader : enable

// 8bit、16bitの値のバッファを読めるようにする拡張を使う
// 頂点バッファをシェーダーから読むのに使う
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_8bit_storage : enable

#extension GL_KHR_shader_subgroup_arithmetic : enable

#define GCT_ENABLE_8BIT_16BIT_STORAGE
#include <gct/scene_graph.h>
#include <gct/global_uniforms.h>
#include <gct/scene_graph/accessor.h>
#include <gct/global_uniforms.h>
#include <gct/constraint.h>

// 1つのローカルワークグループには32スレッドが含まれる
layout(local_size_x = 32, local_size_y = 1 ) in;

// 1つのローカルワークグループから最大で64頂点32プリミティブの線分を出力する
layout(lines, max_vertices = 64, max_primitives = 32) out;

// タスクペイロード
struct task_data {
  // どのノードの下のどのメッシュを描くかを指定するID
  uint resource_pair_id;
  mat4 w2s;
};
taskPayloadSharedEXT task_data td;

void main() {
  // 描画対象のID
  const resource_pair_type id = resource_pair[ push_constants.instance + td.resource_pair_id ];
  // メッシュの情報を取得する
  const primitive_resource_index_type prim = primitive_resource_index[ id.prim ];
  const mesh_type mesh = mesh_pool[ prim.mesh ];

  // 変換行列をタスクペイロードから取り出す
  const mat4 w2s = td.w2s;

  const uint particle_id = gl_WorkGroupID.x * 32u + gl_LocalInvocationID.x;

  const bool in_range = mesh.unique_vertex_count > particle_id;

  const vec3 p0 = in_range ? particle_pool[ mesh.particle_offset + particle_id ].position : vec3( 0, 0, 0 );
  const vec3 n0 = in_range ? particle_pool[ mesh.particle_offset + particle_id ].normal : vec3( 0, 0, 0 );
  //const vec4 n04 = w2s * ( in_range ? read_vertex( accessor_pool[ mesh.accessor + 2u ], particle_id, vec4( 0, 0, 0, 1 ) ) : vec4( 0, 0, 0, 1 ) );
  //const vec3 n0 = n04.xyz / n04.w;

  const uint primitive_id = gl_LocalInvocationID.x;
  const uint primitive_count = min( mesh.unique_vertex_count - gl_WorkGroupID.x * 32u, 32u );
  const uint output_vertex_id = primitive_id * 2u;

  SetMeshOutputsEXT( primitive_count * 2u, primitive_count );

  if( in_range ) {
    gl_MeshVerticesEXT[ output_vertex_id ].gl_Position = w2s * vec4( p0, 1.0 );
    gl_MeshVerticesEXT[ output_vertex_id + 1u ].gl_Position = w2s * vec4( p0 + n0 * 0.1, 1.0 );
    gl_PrimitiveLineIndicesEXT[ primitive_id ] = uvec2( output_vertex_id, output_vertex_id + 1 );
  }
}

